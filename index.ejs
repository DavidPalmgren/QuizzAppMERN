const express = require('express');
const multer = require('multer');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const path = require('path');
require('dotenv').config();
const { MongoClient } = require('mongodb');
const { ObjectId } = require('mongodb');
const cors = require('cors');
const app = express()
const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN;

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

const URI = process.env.MONGO_URI;
const client = new MongoClient(URI);
const database = client.db('main');

const cards = database.collection('cards');
const categories = database.collection('categories');
const courses = database.collection('courses');
const decks = database.collection('decks');
const users = database.collection('users');
const achievements = database.collection('achievments'); //typo is in atlas just deal with it

client.connect()
console.log('connected to mongodb')

const PORT = process.env.PORT || 5555

console.log("running");

//'https://studyapp-dapa-98dcdc34bdde.herokuapp.com/'
//'http://localhost:3000'

// platform access remember to change to real address for production
const corsOptions = {
  origin: 'http://localhost:3000',
  methods: 'GET,POST,DELETE,PUT',
};

app.use(cors(corsOptions));
app.use(express.static(path.join(__dirname, 'frontend/my-react-app/build')));
app.use(express.json())

app.listen(PORT, () => console.log('api running'))

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  },
});

const upload = multer({ dest: 'uploads/' })

app.use('/uploads', express.static('uploads'));

// POST USER BASICALLY
app.post('/api/register', async (req, res) => {
  const { username, email, password } = req.body;

  try {
    const existingUser = await users.findOne({ username });
    const existingEmail = await users.findOne({ email });

    if (existingUser) {
      return res.status(400).json({ message: 'Username already exists' });
    }
    if (existingEmail) {
      return res.status(400).json({ message: 'Email already exists' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    await users.insertOne({ username, email, password: hashedPassword });

    const token = jwt.sign({ username }, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
    });

    res.status(201).json({ message: 'Registration successful', token });
  } catch (error) {
    console.error('Error registering user:', error);
    res.status(500).json({ message: 'Error registering user' });
  }
});

app.get('/api/user', async (req, res) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  try {
    const decodedToken = jwt.verify(token, JWT_SECRET);

    if (!decodedToken.username) {
      return res.status(401).json({ message: 'Unauthorized' });
    }

    const username = decodedToken.username;
    const user = await users.findOne({ username });
    res.status(200).json(user)
  } catch (error) {
    console.error('Error fetching username', error)
    res.status(500).json({ message: 'Internal server error' });
  }
})

app.get('/api/user/:userName', async (req, res) => {
  const username = req.params.userName;

  try {
    const user = await users.findOne({ username });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    delete user.password; //for safety!

    res.status(200).json(user)
  } catch (error) {
    console.error('Error fetching username', error)
    res.status(500).json({ message: 'Internal server error' });
  }
})

app.get('/api/user-progress', async (req, res) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  try {
    const decodedToken = jwt.verify(token, JWT_SECRET);

    if (!decodedToken.username) {
      return res.status(401).json({ message: 'Unauthorized' });
    }

    const username = decodedToken.username;
    const userProgressData = await users.findOne({ username }, { progress: 1 });

    if (userProgressData) {
      res.status(200).json(userProgressData.progress); // Return only the progress array
    } else {
      res.status(404).json({ message: 'User progress data not found' });
    }
  } catch (error) {
    console.error('Error fetching user progress data:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
});
// all of these kind of a mess, cause it's checking if the thing exists to make it backwards compatible with the data structure i had before
app.post('/api/deck/add-comment/:deckId', async (req, res) => {
  const { deckId } = req.params;
  const { comment, rating, username } = req.body;

  try {
    const deck = await database.collection('decks').findOne({ _id: new ObjectId(deckId) });

    if (!deck) {
      return res.status(404).json({ message: 'Deck not found' });
    }

    if (!deck.comments) {
      deck.comments = [];
    }

    if (!deck.ratings) {
      deck.ratings = [];
    }

    const newComment = {
      text: comment,
      rating: rating,
      username: username,
    };

    deck.comments.push(newComment);
    deck.ratings.push(rating);

    const averageRating =
      deck.ratings.reduce((acc, curr) => acc + curr, 0) / deck.ratings.length;

    await database.collection('decks').updateOne(
      { _id: new ObjectId(deckId) },
      {
        $set: {
          comments: deck.comments,
          ratings: deck.ratings,
          averageRating: averageRating,
        },
      }
    );

    res.status(200).json({
      message: 'Comment added successfully',
      averageRating,
    });
  } catch (error) {
    console.error('Error adding comment:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
});

app.get('/api/decks/get-comments/:deckId', async (req, res) => {
  const { deckId } = req.params;

  try {
    const deck = await database.collection('decks').findOne({ _id: new ObjectId(deckId) });

    if (!deck) {
      return res.status(404).json({ message: 'Deck not found' });
    }

    const comments = deck.comments || [];

    res.status(200).json(comments)

  } catch (error) {
    console.error('imlazy')
  }
});


app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;

  try {
    const user = await users.findOne({ username });

    if (!user) {
      return res.status(401).json({ message: 'Authentication failed' });
    }

    // Compare the provided password with the stored hashed password
    const passwordMatch = await bcrypt.compare(password, user.password);

    if (!passwordMatch) {
      return res.status(401).json({ message: 'Authentication failed' });
    }

    const token = jwt.sign({ username }, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
    });

    res.json({ message: 'Login successful', token });
  } catch (error) {
    console.error('Error authenticating user:', error);
    res.status(500).json({ message: 'Error authenticating user' });
  }
});

app.get('/api/decks/:deckId/cards', async (req, res) => {
  const deckId = req.params.deckId;

  try {
    const deck = await decks.findOne({ _id: new ObjectId(deckId) });

    if (!deck) {
      return res.status(404).json({ message: `Deck with ID ${deckId} not found` });
    }

    res.json(deck.cards);
  } catch (error) {
    console.error('Error fetching cards from deck:', error);
    res.status(500).json({ message: 'Error fetching cards from deck', error });
  }
});

app.get('/api/users', async (req, res) => {
  const allUsers = await users.find().toArray();
  const formattedJson = JSON.stringify(allUsers, null, 2);
  res.header('Content-Type', 'application/json');
  res.send(formattedJson);
});
// HUGE F*CKING MESS DONT TOUCH IF U CAN HELP IT
app.post('/api/record-study-session', async (req, res) => {
  const { username, timeSpent, correctAnswers, totalAnswers, cardData } = req.body;

  try {
    const user = await users.findOne({ username: username });

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Update user statistics
    await users.updateOne(
      { username: username },
      {
        $inc: {
          totalTimeStudied: timeSpent,
          totalCorrectAnswers: correctAnswers,
          totalCardsAnswered: totalAnswers,
        },
      }
    );

    for (const card of cardData) {
      const { cardId, answeredCorrectly, masteryRating } = card;
    
      // Find the user's progress for this card
      const existingProgress = user.progress ? user.progress.find((progress) => progress.cardId === cardId) : null;
    
      if (existingProgress) {
        if (answeredCorrectly == true) {
          // If answered correctly, increment masteryRating by 0.5, but not exceeding 3
          const newMasteryRating = Math.min(existingProgress.masteryRating + 0.5, 3);
          await users.updateOne(
            { username: username, 'progress.cardId': cardId },
            {
              $set: {
                'progress.$.answeredCorrectly': false,
                'progress.$.masteryRating': newMasteryRating,
              },
            }
          );
        } else {
          // If answered incorrectly, decrease masteryRating by 1, but not going below 0
          const newMasteryRating = Math.max(existingProgress.masteryRating - 1, 0);
          await users.updateOne(
            { username: username, 'progress.cardId': cardId },
            {
              $set: {
                'progress.$.answeredCorrectly': false,
                'progress.$.masteryRating': newMasteryRating,
              },
            }
          );
        }
      } else {
        // Add new progress if it doesn't exist
        if (answeredCorrectly) {
          // If answered correctly, set masteryRating to 0.5
          await users.updateOne(
            { username: username },
            {
              $push: {
                progress: {
                  cardId: cardId,
                  answeredCorrectly: answeredCorrectly,
                  masteryRating: 0.5,
                },
              },
            }
          );
        } else {
          // If answered incorrectly, set masteryRating to 0
          await users.updateOne(
            { username: username },
            {
              $push: {
                progress: {
                  cardId: cardId,
                  answeredCorrectly: answeredCorrectly,
                  masteryRating: 0,
                },
              },
            }
          );
        }
      }
    }
    


    res.status(200).json({ message: 'User statistics and card data updated successfully' });
  } catch (error) {
    console.error('Error updating user statistics and card data:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
});




app.get('/api/cards', async (req, res) => {
  const allCards = await cards.find().toArray();
  const formattedJson = JSON.stringify(allCards, null, 2); // indentation level
  res.header('Content-Type', 'application/json');
  res.send(formattedJson);
});


// FOR TESTING PURPOSES ONLY
app.post('/api/add-card', upload.single('image'), async (req, res) => {
  const { question, answers, correctAnswerIndex, category, creator, isMultipleChoice } = req.body;
  let image = null;

  const correctIndex = parseInt(correctAnswerIndex, 10);

  if (req.file) {
    image = req.file;
  }

  try {
    // dynamically checking if the answer is correct if correct true
    const formattedAnswers = answers.map((text, index) => ({
      text,
      isCorrect: index === correctIndex,
    }));


    const card = {
      question,
      isMultipleChoice,
      answers: formattedAnswers,
      category,
      creator,
    };

    if (image) {
      card.image = image;
    }

    const result = await cards.insertOne(card);

    res.status(201).json({ message: 'Item was added', insertedId: result.insertedId });
  } catch (error) {
    console.error('Error adding item:', error);
    res.status(500).json({ message: 'Error adding item' });
  }
});

app.get('/api/categories', async (req, res) => {
  const allCategories = await categories.find().toArray();
  const formattedJson = JSON.stringify(allCategories, null, 2); // Indenting with 2 spaces
  res.header('Content-Type', 'application/json');
  res.send(formattedJson);
});

app.get('/api/decks/:category', async (req, res) => {
  const category = req.params.category;

  try {
    const matchingDecks = await decks.find({ category }).toArray();
    const formattedJson = JSON.stringify(matchingDecks, null, 2);
    res.header('Content-Type', 'application/json');
    res.send(formattedJson);
  } catch (error) {
    console.error('Error fetching decks:', error);
    res.status(500).json({ message: 'Error fetching decks', error });
  }
});

app.post('/api/add-category', async (req, res) => {
  const { name } = req.body;

  try {
    // Check if the category already exists
    const existingCategory = await categories.findOne({ name });

    if (existingCategory) {
      res.status(400).json({ message: 'Category already exists' });
      return;
    }

    const result = await categories.insertOne({ name });

    res.status(201).json({ message: 'Custom category created', insertedId: result.insertedId });
  } catch (error) {
    console.error('Error creating custom category:', error);
    res.status(500).json({ message: 'Error creating custom category' });
  }
});

app.get('/api/categories/:categoryName/courses', async (req, res) => {
  const categoryName = req.params.categoryName;

  try {
    const matchingCourses = await courses.find({ category: categoryName }).toArray();

    res.status(200).json(matchingCourses);
  } catch (error) {
    console.error('Error fetching courses for category:', error);
    res.status(500).json({ message: 'Error fetching courses for category', error });
  }
});

app.get('/api/categories/:categoryName/:courseName', async (req, res) => {
  const categoryName = req.params.categoryName;
  const courseName = req.params.courseName;

  try {
    const matchingCourses = await courses.find({ category: categoryName, name: courseName }).toArray();

    res.status(200).json(matchingCourses);
  } catch (error) {
    console.error('Error fetching courses for category and name:', error);
    res.status(500).json({ message: 'Error fetching courses for category and name', error });
  }
});

app.get('/api/decks/:categoryName/:courseName', async (req, res) => {
  const categoryName = req.params.categoryName;
  const courseName = req.params.courseName;

  try {
    const matchingCourses = await decks.find({ category: categoryName, course: courseName }).toArray();

    res.status(200).json(matchingCourses);
  } catch (error) {
    console.error('Error fetching courses for category and name:', error);
    res.status(500).json({ message: 'Error fetching courses for category and name', error });
  }
})

app.post('/api/categories/:categoryName/courses', async (req, res) => {
  const { name } = req.body;
  const categoryName = req.params.categoryName;

  try {
    const existingCategory = await categories.findOne({ name: categoryName });

    if (!existingCategory) {
      return res.status(404).json({ message: `Category ${categoryName} not found` });
    }

    const result = await courses.insertOne({ name, category: categoryName });
    const newCourseData = {
      _id: result.insertedId,
      name,
      category: categoryName,
    };
    res.status(201).json(newCourseData);
  } catch (error) {
    console.error('Error creating course:', error);
    res.status(500).json({ message: 'Error creating course', error });
  }
});
// POST BACKEND
app.post('/api/add-course', async (req, res) => {
  const { name, category } = req.body;

  try {
    const courseExists = await courses.findOne({ name })

    if (courseExists) {
      return res.status(404).json({ message: `Course name already exists!` })
    }

    const result = await courses.insertOne({ name, category });
    const newCourseData = {
      _id: result.insertedId,
      name,
      category,
    };
    res.status(201).json(newCourseData);
  } catch (error) {
    console.error("Error creating course", error);
    res.status(500).json({ message: 'Error creating coruse', error })
  }

});

// POST COURSES FRONTEND
app.post('/api/categories/:categoryId/add-courses', async (req, res) => {
  const { name } = req.body;
  const categoryId = req.params.categoryId;

  try {
    const category = await categories.findOne({ _id: new ObjectId(categoryId) });

    if (!category) {
      return res.status(404).json({ message: `Category with ID ${categoryId} not found` });
    }

    const existingCourse = await courses.findOne({ name, categoryId });

    if (existingCourse) {
      res.status(400).json({ message: 'Course already exists in this category' });
      return;
    }

    const result = await courses.insertOne({ name, categoryId });
    const newCourseData = {
      _id: result.insertedId,
      name,
      categoryId,
    };
    res.status(201).json(newCourseData);
  } catch (error) {
    console.error('Error creating course:', error);
    res.status(500).json({ message: 'Error creating course', error });
  }
});

app.get('/api/courses', async (req, res) => {
  try {
    const allCourses = await courses.find().toArray();
    const formattedJson = JSON.stringify(allCourses, null, 2);
    res.header('Content-Type', 'application/json');
    res.send(formattedJson);
  } catch (error) {
    console.error('Error fetching courses:', error);
    res.status(500).json({ message: 'Error fetching courses', error });
  }
});

app.get('/api/decks', async (req, res) => {
  const allDecks = await decks.find().toArray();
  const formattedJson = JSON.stringify(allDecks, null, 2);
  res.header('Content-Type', 'application/json');
  res.send(formattedJson);
})

app.get('/api/personal-decks', async (req, res) => {
  const author = req.query.author; // username from the query parameter **

  try {
    // Fetch decks that match the author's username depending on how performance works with this i might have to change my approach since going through every single deck doesnt seem very efficient
    // Might try an approach where i simply make the decks children of the user account, and all decks are private by default untill they're published to the public deck schema
    const userDecks = await decks.find({ author }).toArray();
    res.json(userDecks);
  } catch (error) {
    console.error('Error fetching decks:', error);
    res.status(500).json({ message: 'Error fetching decks' });
  }
});

app.post('/api/add-decks', async (req, res) => {
  const { name, cards, category, course, difficulty, author } = req.body;

  const token = req.headers.authorization.split(' ')[1]; // fix

  try {
    const existingCategory = await categories.findOne({ name: category });
    const existingSubject = await courses.findOne({ name: course });

    if (!existingCategory || !existingSubject) {
      return res.status(400).json({ message: 'Category or course not found' });
    }

    const result = await decks.insertOne({ name, cards, category, course, author, difficulty });
    const newDeckData = {
      _id: result.insertedId,
      name,
      cards: [],
      category,
      course,
      author,
      difficulty,
    };
    res.status(201).json(newDeckData); // Send back the new deck data
  } catch (error) {
    console.error('Error creating deck:', error);
    res.status(500).json({ message: 'Error creating deck', error });
  }
});

app.delete('/api/decks/delete/:deckId', async (req, res) => {
  const deckId = req.params.deckId;

  try {
    const deletedDeck = await decks.deleteOne({ _id: new ObjectId(deckId) });

    if (!deletedDeck) {
      return res.status(404).json({ message: `Deck with ID ${deckId} not found` });
    }

    res.status(200).json({ message: `Deck with ID ${deckId} deleted successfully` });
  } catch (error) {
    console.error('Error deleting deck:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
});
// IN USE ADD-CARD
// OLD EXISTING DECK IS RELIC CAN BE REMOVEDD, NOT PROBLEM THO
app.post('/api/add-card/:deckId', upload.single('image'), async (req, res) => {
  const { question, isMultipleChoice, answers, correctAnswerIndex, category, creator } = req.body;
  const deckId = req.params.deckId;
  let image = null;

  const correctIndex = parseInt(correctAnswerIndex, 10);

  if (req.file) {
    image = req.file;
  }
  // Convert all answers to lowercase fix
  try {
    const formattedAnswers = answers.map((text, index) => ({
      text: text.toLowerCase(),
      isCorrect: index === correctIndex,
    }));

    const cardId = new ObjectId();

    const card = {
      _id: cardId,
      question,
      isMultipleChoice,
      answers: formattedAnswers,
      category,
      creator,
    };

    if (image) {
      card.image = image;
    }

    const existingDeck = await decks.findOne({ _id: new ObjectId(deckId) });

    if (!existingDeck) {
      return res.status(404).json({ message: `Deck with ID ${deckId} not found` });
    }

    if (!existingDeck.cards) {
      existingDeck.cards = [];
    }

    existingDeck.cards.push(card);

    const result = await decks.replaceOne({ _id: new ObjectId(deckId) }, existingDeck);

    if (result.modifiedCount === 1) {
      res.status(201).json({ message: 'Card was added to the deck' });
    } else {
      res.status(404).json({ message: `Deck with ID ${deckId} not found` });
    }
  } catch (error) {
    console.error('Error adding card to deck:', error);
    res.status(500).json({ message: 'Error adding card to deck', error });
  }
});

app.get('/api/decks-with-rating', async (req, res) => {
  const gt = parseInt(req.query.gt, 10);
  const limit = parseInt(req.query.limit, 10);


  const decksRated = await decks.find({ averageRating: {$gt: gt} }).limit(limit).toArray();
  res.status(200).json(decksRated)
});


app.get('/api/search', async (req, res) => {
  const search = req.query.search;
  var escapedSearch = escapeRegExp(search);

  if (escapedSearch === 'all') {
    escapedSearch = '.*'
  }

  const decksRes = await decks.find({
    $or: [
      { name: { $regex: new RegExp(`^${escapedSearch}`, 'i') } },
      { category: { $regex: new RegExp(`^${escapedSearch}`, 'i') } },
      { course: { $regex: new RegExp(`^${escapedSearch}`, 'i') } },
      { author: { $regex: new RegExp(`^${escapedSearch}`, 'i') } }
    ]
  }).toArray();
  const categoriesRes = await categories.find({ name: { $regex: new RegExp(`^${escapedSearch}`, 'i') } }).toArray();
  const coursesRes = await courses.find({ name: { $regex: new RegExp(`^${escapedSearch}`, 'i') } }).toArray();

  const results = {
    decks: decksRes,
    categories: categoriesRes,
    courses: coursesRes,
  };

  res.status(200).json(results);
});

app.put('/api/update-card/:deckId/:cardId', async (req, res) => {
  const deckId = req.params.deckId;
  const cardId = req.params.cardId;
  const { question, isMultipleChoice, answers, correctAnswerIndex, category, creator } = req.body;

  // Convert isMultipleChoice to a string
  const isMultipleChoiceString = isMultipleChoice.toString();

  try {
    const deckObjectId = new ObjectId(deckId);
    const cardObjectId = new ObjectId(cardId);

    // Format answers in the same way as in the POST route
    const formattedAnswers = answers.map((answer, index) => ({
      text: answer.toLowerCase(), // Use the provided answer as text
      isCorrect: index === parseInt(correctAnswerIndex, 10),
    }));

    const result = await decks.findOneAndUpdate(
      {
        _id: deckObjectId,
        'cards._id': cardObjectId,
      },
      {
        $set: {
          'cards.$.question': question,
          'cards.$.isMultipleChoice': isMultipleChoiceString, // Use the string value
          'cards.$.answers': formattedAnswers,
          'cards.$.correctAnswerIndex': correctAnswerIndex,
        },
      }
    );

    if (result.value === null) {
      return res.status(404).json({ error: 'Deck or card not found' });
    }

    res.status(200).json({ message: 'Card updated successfully' });
  } catch (error) {
    console.error('Error updating card:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
// so many issues, idk if it's conflicting variable names but it's a mess i should've definetly used abcCollection name instead to avoid this
app.post('/api/add-achievement-to-user', async (req, res) => {
  const { achievementNames, user } = req.body;
  console.log("Request Body:", req.body);

  try {
    const userDoc = await users.findOne({ username: user });

    if (!userDoc) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Process each achievement name in the array
    for (const achievementName of achievementNames) {
      const achievementDoc = await achievements.findOne({ name: achievementName });

      if (!achievementDoc) {
        return res.status(404).json({ message: 'Achievement not found' });
      }

      // Check if the user already has the achievement
      const hasAchievement = userDoc.achievements.some(
        (a) => a.name === achievementName
      );

      if (hasAchievement) {
        return res.status(400).json({ message: `User already has the achievement: ${achievementName}` });
      }

      const timestamp = new Date();
      achievementDoc.timestamp = timestamp;

      await users.updateOne(
        { _id: userDoc._id },
        { $push: { achievements: achievementDoc } }
      );
    }

    return res.status(200).json({ message: 'Achievements added to user' });
  } catch (error) {
    console.error('Error adding achievement to user:', error);
    return res.status(500).json({ message: 'Internal server error' });
  }
});




app.get('/api/get-achievments', async (req, res) => {
  const allAchievements = await achievements.find().toArray();
  res.header('Content-Type', 'application/json');
  res.send(allAchievements);
})

app.get('/api/get-achievements-user/:username', async (req, res) => {
  const { username } = req.params;

  try {
    const userDoc = await users.findOne({ username });

    if (!userDoc) {
      return res.status(404).json({ message: 'User not found' });
    }



    return res.status(200).json(userDoc);
  } catch (error) {
    console.error('Error getting user achievements:', error);
    return res.status(500).json({ message: 'Internal server error' });
  }
});



app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'frontend/my-react-app/build', 'index.html'));
});
